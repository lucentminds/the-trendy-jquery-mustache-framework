/** List jshint ignore directives here. **/
/* jshint node:true */
/* jshint esversion:6 */
/* eslint-env es6 */

const fs = require( 'fs' );
const path = require( 'path' );
const Q = require( 'q' );
const klaw = require( 'klaw' );
const fse = require( 'fs-extra' );
const PATH_TEMPLATE = path.resolve( __dirname, '../template' );


const make = module.exports = function( argv ){ // jshint ignore:line
   const deferred = Q.defer();
   // Determines the thing to make.
   const c_thing = argv._[1];
   const c_thing_name = argv._[2];

   switch( c_thing ) {
      case 'widget':
      break;


      default:
      console.error( `Invalid thing to make: ${c_thing}` );
      return deferred.reject( `Invalid thing to make: ${c_thing}` );

   }// /switch()

   if( !c_thing_name ){
      console.error( `Missing thing name` );
      return deferred.reject( `Missing thing name` );
   }
   

   // "ui-super-duper-widget" to "super-duper-widget" or
   // "ui-Super-Duper-Widget" to "super-duper-widget"
   const cNameLower = c_thing_name.replace( /^ui-/, '' ).toLowerCase();

   // "super-duper-widget" to "SuperDuperWidget"
   const cCamel = toCamelCase( '-'.concat( cNameLower ) );

   // "SuperDuperWidget" to "superDuperWidget"
   const cNameLowerFirstChar = lowerCaseFirstLetter( cCamel );

   const o_config = {
      // Determines which file extensions we should ignore and NOT copy.
      ignoreExtensions: [],

      // Determines the path to copy the source files to.
      path_destination: path.resolve( `./${c_thing_name}` ),

      // Determines the path to copy the source files from.
      path_source: PATH_TEMPLATE,

      // Determines the list of file renames.
      rename: {
         "src/name.css": "src/{%= name %}.css",
         "src/name.htm": "src/{%= name %}.htm",
         "src/name.js": "src/{%= name %}.js"
      },

      replacements: {
         name: c_thing_name,
         name_lower: cNameLower,
         name_camel: cCamel,
         name_lower_first_char: cNameLowerFirstChar,
         date: dateToMDY()
      }
   };


   copy_files( o_config );

   return deferred.promise;
};// /make()

const copy_files = function( oProps ) {
   var deferred = Q.defer();
   var self = this;
   var oFileMap, i,l, cContent, cFileIn, cFileOut, cFileExt, oStatIn;
   var cPathType, cFilePathRelative;

   const oSettings = Object.assign({
      // Determines which file extensions we should ignore and NOT copy.
      ignoreExtensions: [],

      // Determines the path to copy the source files to.
      path_destination: '',

      // Determines the path to copy the source files from.
      path_source: '',

      // Determines the list of file renames.
      rename: {}
   }, oProps );


   /**
    * First create a map of all path_source file names to all path_destination
    * file names.
    */
   createPathMap( oSettings )
   .then(function( aMap ){
      /**
       * Loop over each file in the files directory and copy them to the new
       * project location.
       */
      for( i = 0, l = aMap.length; i < l; i++ ) {
         oFileMap = aMap[ i ];
         cFilePathRelative = oFileMap.path_relative;
         cFileExt = oFileMap.extension;

         // Ignore certain file types that might have been generated by vfp.
         if ( oSettings.ignoreExtensions.indexOf( cFileExt ) > -1 ) {
            // This is an ignored file type.
            console.log( ' ' );
            console.log( 'continue:', cFilePathRelative );
            console.log( ' ' );
            continue;
         }

         cFileIn = oFileMap.path_source;
         cFileOut = oFileMap.path_destination;
         oStatIn = fs.lstatSync( cFileIn );

         switch( true ){
         case oStatIn.isDirectory():
            cPathType = 'directory';
            break;

         case oStatIn.isFile():
            cPathType = 'file';
            break;

         default:
            cPathType = '*unknown*';
         }// /switch()



         console.log( 'Adding', cPathType, cFileOut, '...' );
         
         // Make sure the full destination path exists.
         fse.ensureFileSync( cFileOut );

         
         cContent = fse.readFileSync( cFileIn, 'utf8' );
         cContent = replaceTokens( cContent, oSettings.replacements );
         fse.writeFileSync( cFileOut, cContent, 'utf8' );
      }// /for()
      
      deferred.resolve();
   }).done();

   return deferred.promise;
};// /copyFiles()


const createPathMap = function( oSettings ) {
   var deferred = Q.defer();
   //var self = this;
   var cPathRelative, oStatIn, aMap = [];
   //var cPathSourceDir = oSettings.path_source.concat( '\\' );
   var cPathSourceDir = oSettings.path_source.concat( path.sep );
   var cReplacementPath;

   //fse.walk( oSettings.path_source )
   klaw( oSettings.path_source )
      .on( 'data', function( oItem ) {
         oStatIn = fs.lstatSync( oItem.path );
         cPathRelative = oItem.path
            .replace( cPathSourceDir, '' )
            .replace( /\\/g, '/' );

         if ( oStatIn.isDirectory() ) {
            return;
         }

         cReplacementPath = oSettings.rename[ cPathRelative ];
         if( cReplacementPath ){
            cPathRelative = replaceTokens( cReplacementPath, oSettings.replacements );
         }

         aMap.push({
            extension: path.extname( oItem.path ).toLowerCase(),
            path_destination: path.join( oSettings.path_destination, cPathRelative ),
            path_relative: cPathRelative,
            path_source: oItem.path
         });
         //
         //console.log( ' ' );
         //console.log( oItem.path );

      })
      .on( 'end', function() {
         /* var cFilepath = ''; */
         //console.log( oSettings );
         //console.log( ' ' );
         //console.log( aMap );
         //console.log( ' ' );
         //process.exit();

         deferred.resolve( aMap );

      }.bind( this ));

   return deferred.promise;
};// /_createPathMap()

const dateToMDY = function(){
   var PAD_STRING = '00';
   var oD = new Date();
   var month = ''.concat( oD.getMonth()+1 );
   var date = ''.concat( oD.getDate() );

   month = PAD_STRING.substring( 0, 2 - month.length ).concat( month );
   date = PAD_STRING.substring( 0, 2 - date.length ).concat( date );

   return [month,date,oD.getFullYear()].join( '-' );
}; // /dateToMDY()

const lowerCaseFirstLetter = function( string ) { // jshint ignore:line
  return string.charAt(0).toLowerCase() + string.slice(1);
};// /lowerCaseFirstLetter()


//http://stackoverflow.com/questions/2970525/converting-any-string-into-camel-case
const toCamelCase = function( str ) { // jshint ignore:line

   str = str.replace(/[^a-z,A-Z,0-9](.)/g, function($1) { return $1.toUpperCase(); });
   str = str.replace(/[^a-z,A-Z,0-9]/g, '');
    return str;
};// /toCamelCase()



/**
 * This method replaces all templated tokens found in a string with values found
 * in this instance's settings.
 */
const replaceTokens = function( cString, o_replacements ) {
	var n, r;

	/**
	 * Loop over each setting and make a replacement with it's corresponding
	 * template token in this string if any. If there is not corresponding token
	 * name, we will leave it alone.
	 */
	for( n in o_replacements ){
		r = new RegExp( ''.concat( '{%= ',n,' %}' ), 'g' );
		cString = cString.replace( r, o_replacements[n] );
	}// /for()

	return cString;
};// /replaceTokens()